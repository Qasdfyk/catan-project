# --- CATAN BACKEND SNAPSHOT ---


============================================================
FILE: Dockerfile
============================================================
# 1. BASE: Use official Python 3.12 slim image
FROM python:3.12-slim

# 2. ENV VARS: 
# PYTHONDONTWRITEBYTECODE=1 -> Prevent .pyc files
# PYTHONUNBUFFERED=1 -> Log to console immediately (crucial for Docker logs)
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# 3. WORKDIR: Set working directory inside the container
WORKDIR /app

# 4. SYSTEM DEPENDENCIES: Install curl for healthchecks
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

# 5. INSTALL DEPENDENCIES:
# Copy requirements first to leverage Docker cache
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 6. COPY CODE: Copy local source code to container
COPY . .

# 7. PORT: Expose port 8000
EXPOSE 8000

# 8. START: Run uvicorn server
# Host 0.0.0.0 is required to make the server accessible outside the container
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

============================================================
FILE: debug_client.py
============================================================
import asyncio
import socketio

# Tworzymy klienta Socket.IO
sio = socketio.AsyncClient()

@sio.event
async def connect():
    print("âœ… PoÅ‚Ä…czono z serwerem!")
    print("ðŸ“¤ WysyÅ‚am Å¼Ä…danie: create_test_game")
    # Emitujemy zdarzenie, ktÃ³re zdefiniowaliÅ›my w main.py
    await sio.emit('create_test_game')

@sio.event
async def disconnect():
    print("âŒ RozÅ‚Ä…czono.")

@sio.event
async def test_response(data):
    # To zdarzenie przyjdzie z serwera po odczytaniu gry z Redisa
    print(f"ðŸ“¥ OTRZYMANO ODPOWIEDÅ¹ Z SERWERA: {data}")
    # JeÅ›li status jest success, test zaliczony
    if data.get('status') == 'success':
        print("ðŸ† TEST ZAKOÅƒCZONY SUKCESEM: Gra zapisana i odczytana z Redisa przez WebSocket!")
    else:
        print("ðŸ’€ BÅÄ„D: CoÅ› poszÅ‚o nie tak.")
    
    await sio.disconnect()

async def main():
    try:
        # ÅÄ…czymy siÄ™ z lokalnym serwerem
        await sio.connect('http://localhost:8000')
        # Czekamy chwilÄ™, Å¼eby zdarzenia mogÅ‚y spÅ‚ynÄ…Ä‡
        await sio.wait()
    except Exception as e:
        print(f"BÅ‚Ä…d poÅ‚Ä…czenia: {e}")

if __name__ == '__main__':
    asyncio.run(main())

============================================================
FILE: app/__init__.py
============================================================


============================================================
FILE: app/main.py
============================================================
import socketio
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from app.services.redis_service import RedisService
from app.socket.events import register_socket_events
from app.api.routes import router as api_router

ORIGINS = [
    "http://localhost:5173",
    "http://127.0.0.1:5173"
]


sio = socketio.AsyncServer(
    async_mode='asgi',
    cors_allowed_origins=[] 
)

@asynccontextmanager
async def lifespan(app: FastAPI):
    app.state.redis = RedisService()
    register_socket_events(sio, app.state)
    yield
    await app.state.redis.close()

app = FastAPI(lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(api_router, prefix="/api")

socket_app = socketio.ASGIApp(sio, app)
app.mount("/", socket_app)

@app.get("/health")
async def health_check():
    return {"status": "ok", "service": "catan-backend"}

============================================================
FILE: app/api/routes.py
============================================================
import uuid
from datetime import datetime
from fastapi import APIRouter, HTTPException, Request
from app.schemas.game_schemas import GameCreateRequest, GameResponse
from app.models.game import GameState
from app.services.serializer import GameSerializer
from app.services.redis_service import RedisService

router = APIRouter()

@router.post("/games", response_model=GameResponse)
async def create_game(request: Request, body: GameCreateRequest):
    """
    Tworzy nowÄ… grÄ™, zapisuje jÄ… w Redis i zwraca room_id.
    """
    # 1. Generujemy unikalny ID pokoju
    room_id = str(uuid.uuid4())[:8] # np. "a1b2c3d4"
    
    # 2. Tworzymy logikÄ™ gry (Python Core)
    try:
        game = GameState.create_new_game(body.player_names)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    
    # 3. Serializacja
    game_dict = GameSerializer.game_to_dict(game)
    
    # 4. Zapis do Redis (uÅ¼ywamy serwisu z app.state)
    redis: RedisService = request.app.state.redis
    await redis.save_game_state(room_id, game_dict)
    
    return GameResponse(
        room_id=room_id,
        status="created",
        created_at=datetime.now().isoformat(),
        players=[p.name for p in game.players]
    )

@router.get("/games/{room_id}")
async def get_game_state(request: Request, room_id: str):
    """
    Zwraca aktualny stan gry z Redisa (np. dla debugowania lub reconnectu).
    """
    redis: RedisService = request.app.state.redis
    game_data = await redis.get_game_state(room_id)
    
    if not game_data:
        raise HTTPException(status_code=404, detail="Game not found")
        
    return game_data

============================================================
FILE: app/models/board.py
============================================================
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional
import random

from app.models.hex_lib import Hex

class ResourceType(str, Enum):
    """Available resource types in the game."""
    WOOD = "wood"
    BRICK = "brick"
    SHEEP = "sheep"
    WHEAT = "wheat"
    ORE = "ore"
    DESERT = "desert"

@dataclass
class Tile:
    """Represents a single tile on the board with a resource and a dice number."""
    hex_coords: Hex
    resource: ResourceType
    number: Optional[int] = None  # None for Desert

class Board:
    """
    Manages the game board state.
    Stores tiles in a dictionary for O(1) access using Hex coordinates.
    """
    def __init__(self):
        self.tiles: Dict[Hex, Tile] = {}

    def get_tile(self, hex_coords: Hex) -> Optional[Tile]:
        """Retrieve a tile by its coordinates."""
        return self.tiles.get(hex_coords)

    @staticmethod
    def create_standard_game() -> 'Board':
        """
        Factory method to create a standard Catan board (Radius 2).
        - 19 Tiles total.
        - Randomly assigns resources and number tokens.
        """
        board = Board()
        
        # 1. Generate Coordinates for Radius 2 (Standard map)
        hexes = Board._generate_hex_grid(radius=2)
        
        # 2. Define Standard Resource Distribution
        # 4 Wood, 4 Sheep, 4 Wheat, 3 Brick, 3 Ore, 1 Desert
        resources = (
            [ResourceType.WOOD] * 4 +
            [ResourceType.SHEEP] * 4 +
            [ResourceType.WHEAT] * 4 +
            [ResourceType.BRICK] * 3 +
            [ResourceType.ORE] * 3 +
            [ResourceType.DESERT] * 1
        )
        
        # 3. Define Standard Number Tokens (probabilities)
        # 2-12 (skipping 7). Distribution tailored for 19 tiles minus 1 desert = 18 tokens.
        # 1x2, 2x3, 2x4, 2x5, 2x6, 2x8, 2x9, 2x10, 2x11, 1x12
        numbers = [2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 8, 9, 9, 10, 10, 11, 11, 12]

        # 4. Shuffle resources and numbers
        random.shuffle(resources)
        random.shuffle(numbers)

        # 5. Assign to tiles
        # Note: In a real game, there are rules preventing 6s and 8s from touching.
        # For this iteration, we use pure random assignment.
        number_idx = 0
        
        for i, h in enumerate(hexes):
            res = resources[i]
            num = None
            
            if res != ResourceType.DESERT:
                num = numbers[number_idx]
                number_idx += 1
            
            board.tiles[h] = Tile(hex_coords=h, resource=res, number=num)

        return board

    @staticmethod
    def _generate_hex_grid(radius: int) -> List[Hex]:
        """
        Generates a list of Hex coordinates forming a spiral/circle of given radius.
        Radius 2 means center + 2 rings.
        """
        hexes = []
        for q in range(-radius, radius + 1):
            r1 = max(-radius, -q - radius)
            r2 = min(radius, -q + radius)
            for r in range(r1, r2 + 1):
                s = -q - r
                hexes.append(Hex(q, r, s))
        return hexes

============================================================
FILE: app/models/__init__.py
============================================================


============================================================
FILE: app/models/player.py
============================================================
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict
from collections import Counter

from app.models.board import ResourceType

class PlayerColor(str, Enum):
    RED = "red"
    BLUE = "blue"
    WHITE = "white"
    ORANGE = "orange"

@dataclass
class Player:
    """
    Represents a player in the game.
    Tracks resources, victory points, and identifiers.
    """
    name: str
    color: PlayerColor
    # Resources are stored in a Counter for easy addition/subtraction
    resources: Counter = field(default_factory=Counter)
    victory_points: int = 0
    
    # Will be used later for authentication
    id: str = field(default="") 

    def add_resource(self, resource: ResourceType, amount: int = 1):
        """Adds resources to the player's hand."""
        self.resources[resource] += amount

    def remove_resource(self, resource: ResourceType, amount: int = 1):
        """
        Removes resources. 
        Raises ValueError if player doesn't have enough.
        """
        if self.resources[resource] < amount:
            raise ValueError(f"Not enough {resource}. Has {self.resources[resource]}, needs {amount}.")
        self.resources[resource] -= amount

    def has_resources(self, cost: Dict[ResourceType, int]) -> bool:
        """
        Checks if player can afford a specific cost.
        Example cost: {ResourceType.WOOD: 1, ResourceType.BRICK: 1}
        """
        for res, amount in cost.items():
            if self.resources[res] < amount:
                return False
        return True

    def deduct_resources(self, cost: Dict[ResourceType, int]):
        """
        Deducts resources for a cost. 
        Raises ValueError if not affordable (atomic operation check needed in caller or here).
        """
        if not self.has_resources(cost):
            raise ValueError("Insufficient resources to pay cost.")
        
        for res, amount in cost.items():
            self.remove_resource(res, amount)

============================================================
FILE: app/models/game.py
============================================================
# ============================================================
# FILE: app/models/game.py
# ============================================================
from typing import List, Optional, Dict
import random
from dataclasses import dataclass, field
from enum import Enum

from app.models.board import Board, ResourceType, Tile
from app.models.player import Player, PlayerColor
from app.models.hex_lib import Edge, Vertex, Hex

class TurnPhase(str, Enum):
    ROLL_DICE = "roll_dice"
    MAIN_PHASE = "main_phase"

class BuildingType(str, Enum):
    SETTLEMENT = "settlement"
    CITY = "city"

@dataclass
class Building:
    owner: PlayerColor
    type: BuildingType

@dataclass
class GameState:
    """
    The root entity for the game logic.
    """
    board: Board
    players: List[Player] = field(default_factory=list)
    current_turn_index: int = 0
    dice_roll: Optional[int] = None
    turn_phase: TurnPhase = TurnPhase.ROLL_DICE
    
    # Robber position (initially should be on Desert)
    robber_hex: Optional[Hex] = None 

    is_game_over: bool = False
    winner: Optional[Player] = None
    
    # State of the board
    roads: Dict[Edge, PlayerColor] = field(default_factory=dict)
    # Now maps Vertex -> Building object
    settlements: Dict[Vertex, Building] = field(default_factory=dict)

    @staticmethod
    def create_new_game(player_names: List[str]) -> 'GameState':
        if len(player_names) < 2 or len(player_names) > 4:
            raise ValueError("Game requires 2 to 4 players.")

        board = Board.create_standard_game()
        players = []
        colors = list(PlayerColor)
        
        for i, name in enumerate(player_names):
            players.append(Player(name=name, color=colors[i]))

        # Find Desert to place Robber initially
        desert_hex = next((t.hex_coords for t in board.tiles.values() if t.resource == ResourceType.DESERT), Hex(0,0,0))

        return GameState(
            board=board, 
            players=players,
            robber_hex=desert_hex
        )

    def get_current_player(self) -> Player:
        return self.players[self.current_turn_index]

    def next_turn(self):
        self._check_victory()
        if self.is_game_over:
            return

        self.current_turn_index = (self.current_turn_index + 1) % len(self.players)
        self.dice_roll = None
        self.turn_phase = TurnPhase.ROLL_DICE

    def roll_dice(self) -> int:
        if self.turn_phase != TurnPhase.ROLL_DICE:
            raise ValueError("Cannot roll dice in MAIN_PHASE.")

        d1 = random.randint(1, 6)
        d2 = random.randint(1, 6)
        self.dice_roll = d1 + d2
        
        self.turn_phase = TurnPhase.MAIN_PHASE

        if self.dice_roll == 7:
            # Phase 1: Just wait for move_robber
            pass
        else:
            self.distribute_resources(self.dice_roll)
        
        return self.dice_roll

    def distribute_resources(self, roll_number: int):
        matching_tiles = [t for t in self.board.tiles.values() if t.number == roll_number]

        for tile in matching_tiles:
            # ROBBER LOGIC
            if tile.hex_coords == self.robber_hex:
                continue
            
            if tile.resource == ResourceType.DESERT:
                continue

            for direction in range(6):
                raw_vertex = Vertex(tile.hex_coords, direction)
                canonical_vertex = raw_vertex.get_canonical()

                if canonical_vertex in self.settlements:
                    building = self.settlements[canonical_vertex]
                    player = next((p for p in self.players if p.color == building.owner), None)
                    
                    if player:
                        amount = 2 if building.type == BuildingType.CITY else 1
                        player.add_resource(tile.resource, amount)

    def move_robber(self, player: Player, target_hex: Hex):
        self._verify_turn(player)
        if target_hex == self.robber_hex:
             raise ValueError("Robber must be moved to a new location.")
        if target_hex not in self.board.tiles:
            raise ValueError("Invalid hex coordinates.")
        
        self.robber_hex = target_hex

    # --- Building Logic ---

    def place_road(self, player: Player, edge: Edge, free: bool = False):
        if not free:
            self._verify_turn(player)

        canonical_edge = edge.get_canonical()

        if canonical_edge in self.roads:
            raise ValueError("This edge is already occupied.")

        road_cost = {ResourceType.WOOD: 1, ResourceType.BRICK: 1}
        if not free and not player.has_resources(road_cost):
            raise ValueError("Insufficient resources for a road.")

        if not self._has_road_connectivity(player, canonical_edge):
             raise ValueError("Road must be connected to your existing network.")

        if not free:
            player.deduct_resources(road_cost)
        
        self.roads[canonical_edge] = player.color
        self._check_longest_road(player)

    def place_settlement(self, player: Player, vertex: Vertex, free: bool = False):
        if not free:
            self._verify_turn(player)

        canonical_vertex = vertex.get_canonical()

        if canonical_vertex in self.settlements:
            raise ValueError("This intersection is already occupied.")

        neighbors = canonical_vertex.get_adjacent_vertices()
        for n in neighbors:
            if n in self.settlements:
                raise ValueError("Distance Rule: Cannot build next to another settlement.")

        if not free:
            if not self._has_settlement_connectivity(player, canonical_vertex):
                 raise ValueError("Settlement must be connected to your road.")

        settlement_cost = {
            ResourceType.WOOD: 1, ResourceType.BRICK: 1,
            ResourceType.WHEAT: 1, ResourceType.SHEEP: 1
        }
        if not free and not player.has_resources(settlement_cost):
            raise ValueError("Insufficient resources for a settlement.")

        if not free:
            player.deduct_resources(settlement_cost)
        
        self.settlements[canonical_vertex] = Building(player.color, BuildingType.SETTLEMENT)
        player.victory_points += 1
        self._check_victory()

    def upgrade_to_city(self, player: Player, vertex: Vertex):
        self._verify_turn(player)
        canonical_vertex = vertex.get_canonical()

        building = self.settlements.get(canonical_vertex)
        if not building:
            raise ValueError("No settlement at this location.")
        if building.owner != player.color:
            raise ValueError("You can only upgrade your own settlements.")
        if building.type == BuildingType.CITY:
            raise ValueError("This is already a city.")

        city_cost = {ResourceType.ORE: 3, ResourceType.WHEAT: 2}
        if not player.has_resources(city_cost):
             raise ValueError("Insufficient resources for a city.")

        player.deduct_resources(city_cost)
        building.type = BuildingType.CITY
        player.victory_points += 1 
        self._check_victory()

    def trade_with_bank(self, player: Player, give: ResourceType, get: ResourceType):
        self._verify_turn(player)
        if player.resources[give] < 4:
            raise ValueError(f"Not enough {give} to trade. Need 4.")
        
        player.remove_resource(give, 4)
        player.add_resource(get, 1)

    # --- Helpers ---

    def _verify_turn(self, player: Player):
        if player != self.get_current_player():
            raise ValueError("It is not your turn.")
        if self.turn_phase == TurnPhase.ROLL_DICE:
             raise ValueError("You must roll the dice first.")

    def _check_victory(self):
        p = self.get_current_player()
        if p.victory_points >= 10:
            self.is_game_over = True
            self.winner = p

    def _check_longest_road(self, player: Player):
        # Placeholder for Phase 1 logic
        # In future phases, this will run BFS/DFS to calculate road length
        pass

    def _has_road_connectivity(self, player: Player, edge: Edge) -> bool:
        connected_edges = edge.get_connected_edges()
        for e in connected_edges:
            if self.roads.get(e) == player.color:
                return True
        
        vertices = edge.get_vertices()
        for v in vertices:
            building = self.settlements.get(v)
            if building and building.owner == player.color:
                return True
        return False

    def _has_settlement_connectivity(self, player: Player, vertex: Vertex) -> bool:
        touching_edges = vertex.get_touching_edges()
        for e in touching_edges:
            if self.roads.get(e) == player.color:
                return True
        return False

============================================================
FILE: app/models/hex_lib.py
============================================================
from dataclasses import dataclass
from typing import List, Tuple, Set

@dataclass(frozen=True, order=True)
class Hex:
    """
    Representation of a single hexagonal tile using Cube Coordinates system.
    Constraint: q + r + s = 0
    """
    q: int
    r: int
    s: int

    def __post_init__(self):
        if self.q + self.r + self.s != 0:
            raise ValueError("Sum of coordinates q + r + s must be 0!")

    def __add__(self, other: 'Hex') -> 'Hex':
        return Hex(self.q + other.q, self.r + other.r, self.s + other.s)

    def __sub__(self, other: 'Hex') -> 'Hex':
        return Hex(self.q - other.q, self.r - other.r, self.s - other.s)

    def neighbor(self, direction: int) -> 'Hex':
        directions = [
            Hex(1, 0, -1), Hex(1, -1, 0), Hex(0, -1, 1),
            Hex(-1, 0, 1), Hex(-1, 1, 0), Hex(0, 1, -1)
        ]
        return self + directions[direction % 6]
    
    def length(self) -> int:
        return (abs(self.q) + abs(self.r) + abs(self.s)) // 2

    def distance(self, other: 'Hex') -> int:
        return (self - other).length()

@dataclass(frozen=True)
class Vertex:
    """
    Represents a corner of a hex.
    """
    owner: Hex
    direction: int

    def get_canonical(self) -> 'Vertex':
        """Returns the unique, canonical representation of this vertex."""
        h1 = self.owner
        d1 = self.direction % 6
        
        h2 = h1.neighbor(d1)
        d2 = (d1 + 4) % 6
        
        h3 = h1.neighbor((d1 - 1) % 6)
        d3 = (d1 + 2) % 6

        candidates = [(h1, d1), (h2, d2), (h3, d3)]
        best_hex, best_dir = min(candidates, key=lambda x: (x[0].q, x[0].r, x[0].s))
        return Vertex(best_hex, best_dir)

    def get_adjacent_vertices(self) -> List['Vertex']:
        """
        Returns the 3 vertices connected to this vertex via edges.
        Used for the 'Distance Rule' (settlements cannot be adjacent).
        """
        edges = self.get_touching_edges()
        result = set()
        for edge in edges:
            # Each edge has 2 vertices. One is 'self', the other is the neighbor.
            vs = edge.get_vertices()
            for v in vs:
                # We only want the OTHER vertex, not ourselves
                if v.get_canonical() != self.get_canonical():
                    result.add(v.get_canonical())
        return list(result)

    def get_touching_edges(self) -> List['Edge']:
        """
        Returns the 3 edges that meet at this vertex.
        """
        # The 3 edges meeting at Vertex(H, d) are:
        # 1. Edge(H, d)   -> The edge "forward" clockwise
        # 2. Edge(H, d-1) -> The edge "backward" counter-clockwise
        # 3. The "spine" edge between the two neighbors.
        #    Neighbor(d) is the hex at direction d.
        #    The shared edge between Neighbor(d) and Neighbor(d-1) is at index 4 relative to Neighbor(d).
        
        edges = [
            Edge(self.owner, self.direction).get_canonical(),
            Edge(self.owner, (self.direction - 1) % 6).get_canonical(),
            # FIX: Changed offset from +2 to +4 to correctly identify the shared edge between neighbors
            Edge(self.owner.neighbor(self.direction), (self.direction + 4) % 6).get_canonical()
        ]
        return edges

    def __repr__(self):
        return f"Vertex({self.owner}, dir={self.direction})"

@dataclass(frozen=True)
class Edge:
    """
    Represents a side of a hex.
    """
    owner: Hex
    direction: int

    def get_canonical(self) -> 'Edge':
        h1 = self.owner
        d1 = self.direction % 6
        h2 = h1.neighbor(d1)
        d2 = (d1 + 3) % 6 
        candidates = [(h1, d1), (h2, d2)]
        best_hex, best_dir = min(candidates, key=lambda x: (x[0].q, x[0].r, x[0].s))
        return Edge(best_hex, best_dir)
    
    def get_vertices(self) -> List[Vertex]:
        """Returns the 2 vertices at the ends of this edge."""
        # Edge 'd' sits between Vertex 'd' and Vertex 'd+1'
        v1 = Vertex(self.owner, self.direction).get_canonical()
        v2 = Vertex(self.owner, (self.direction + 1) % 6).get_canonical()
        return [v1, v2]

    def get_connected_edges(self) -> List['Edge']:
        """
        Returns the 4 edges connected to this edge (2 at each end).
        Used for finding 'Longest Road'.
        """
        v1, v2 = self.get_vertices()
        connected = set()
        
        for e in v1.get_touching_edges():
            if e.get_canonical() != self.get_canonical():
                connected.add(e.get_canonical())
                
        for e in v2.get_touching_edges():
            if e.get_canonical() != self.get_canonical():
                connected.add(e.get_canonical())
                
        return list(connected)

    def __repr__(self):
        return f"Edge({self.owner}, dir={self.direction})"

============================================================
FILE: app/socket/events.py
============================================================
import socketio
from app.models.game import GameState
from app.services.serializer import GameSerializer
from app.services.redis_service import RedisService

def register_socket_events(sio: socketio.AsyncServer, app_state):
    """
    Registers all Socket.IO event handlers.
    """

    @sio.event
    async def connect(sid, environ):
        print(f"Client connected: {sid}")

    @sio.event
    async def disconnect(sid):
        print(f"Client disconnected: {sid}")

    @sio.event
    async def create_test_game(sid):
        """
        Handler for creating a test game.
        """
        print(f"Processing create_test_game for {sid}...")
        
        # 1. Game Logic
        game = GameState.create_new_game(["Player1", "Player2"])
        room_id = "room_test_1"
        
        # 2. Serialization
        game_dict = GameSerializer.game_to_dict(game)
        
        # 3. Save to Redis (Accessing RedisService from app state)
        # Note: In FastAPI+SocketIO, passing app state is tricky, 
        # so often we instantiate services or use dependency injection.
        # Here we assume app_state has the redis instance.
        redis: RedisService = app_state.redis
        await redis.save_game_state(room_id, game_dict)
        
        # 4. Load back to verify
        loaded_dict = await redis.get_game_state(room_id)
        
        if loaded_dict:
            loaded_game = GameSerializer.dict_to_game(loaded_dict)
            await sio.emit('test_response', {
                'status': 'success', 
                'player': loaded_game.get_current_player().name
            }, room=sid)
        else:
            await sio.emit('test_response', {'status': 'error'}, room=sid)

============================================================
FILE: app/core/config.py
============================================================
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    PROJECT_NAME: str = "Catan Backend"
    REDIS_URL: str = "redis://localhost:6379/0"
    
    model_config = SettingsConfigDict(env_file=".env", extra="ignore")

settings = Settings()

============================================================
FILE: app/services/redis_service.py
============================================================
import json
from redis.asyncio import Redis
from app.core.config import settings

class RedisService:
    def __init__(self):
        self.redis = Redis.from_url(settings.REDIS_URL, decode_responses=True)

    async def save_game_state(self, room_id: str, game_data: dict, ttl: int = 3600):
        key = f"game:{room_id}"
        await self.redis.set(key, json.dumps(game_data), ex=ttl)

    async def get_game_state(self, room_id: str) -> dict | None:
        key = f"game:{room_id}"
        data = await self.redis.get(key)
        if data:
            return json.loads(data)
        return None

    async def close(self):
        await self.redis.aclose()

============================================================
FILE: app/services/serializer.py
============================================================
from typing import Dict, Any, List
import json
from app.models.game import GameState, Building, TurnPhase, BuildingType
from app.models.board import Board, Tile, ResourceType
from app.models.player import Player, PlayerColor
from app.models.hex_lib import Hex, Vertex, Edge

class GameSerializer:
    """
    Responsibility: Convert complex GameState objects to JSON-compatible dictionaries and back.
    Crucial for storing state in Redis.
    """

    @staticmethod
    def game_to_dict(game: GameState) -> Dict[str, Any]:
        return {
            "players": [GameSerializer._player_to_dict(p) for p in game.players],
            "current_turn_index": game.current_turn_index,
            "turn_phase": game.turn_phase.value,
            "dice_roll": game.dice_roll,
            "robber_hex": GameSerializer._hex_to_dict(game.robber_hex) if game.robber_hex else None,
            "is_game_over": game.is_game_over,
            "winner_name": game.winner.name if game.winner else None,
            "board_tiles": GameSerializer._tiles_to_list(game.board.tiles),
            "roads": GameSerializer._roads_to_list(game.roads),
            "settlements": GameSerializer._settlements_to_list(game.settlements)
        }

    @staticmethod
    def dict_to_game(data: Dict[str, Any]) -> GameState:
        # Reconstruct Board
        board = Board()
        # We assume the board structure (hexes) is static for a standard game, 
        # but here we reload the resources/numbers from state.
        board.tiles = GameSerializer._list_to_tiles(data["board_tiles"])

        # Reconstruct Players
        players = [GameSerializer._dict_to_player(p) for p in data["players"]]

        # Reconstruct GameState
        game = GameState(
            board=board,
            players=players,
            current_turn_index=data["current_turn_index"],
            dice_roll=data["dice_roll"],
            turn_phase=TurnPhase(data["turn_phase"]),
            robber_hex=GameSerializer._dict_to_hex(data["robber_hex"]) if data["robber_hex"] else None,
            is_game_over=data["is_game_over"]
        )
        
        # Restore complex dicts
        game.roads = GameSerializer._list_to_roads(data["roads"])
        game.settlements = GameSerializer._list_to_settlements(data["settlements"])
        
        if data["winner_name"]:
            game.winner = next((p for p in players if p.name == data["winner_name"]), None)

        return game

    # --- Helpers for Nested Objects ---

    @staticmethod
    def _hex_to_dict(h: Hex) -> Dict[str, int]:
        return {"q": h.q, "r": h.r, "s": h.s}

    @staticmethod
    def _dict_to_hex(d: Dict[str, int]) -> Hex:
        return Hex(q=d['q'], r=d['r'], s=d['s'])

    @staticmethod
    def _player_to_dict(p: Player) -> Dict[str, Any]:
        return {
            "name": p.name,
            "color": p.color.value,
            "resources": dict(p.resources), # Counter to dict
            "victory_points": p.victory_points
        }

    @staticmethod
    def _dict_to_player(d: Dict[str, Any]) -> Player:
        p = Player(name=d["name"], color=PlayerColor(d["color"]))
        p.victory_points = d["victory_points"]
        for res_str, amount in d["resources"].items():
            p.resources[ResourceType(res_str)] = amount
        return p

    @staticmethod
    def _tiles_to_list(tiles: Dict[Hex, Tile]) -> List[Dict]:
        """Convert Map<Hex, Tile> to List of objects for JSON."""
        result = []
        for h, tile in tiles.items():
            result.append({
                "hex": GameSerializer._hex_to_dict(h),
                "resource": tile.resource.value,
                "number": tile.number
            })
        return result

    @staticmethod
    def _list_to_tiles(data: List[Dict]) -> Dict[Hex, Tile]:
        result = {}
        for item in data:
            h = GameSerializer._dict_to_hex(item["hex"])
            result[h] = Tile(
                hex_coords=h,
                resource=ResourceType(item["resource"]),
                number=item["number"]
            )
        return result

    @staticmethod
    def _roads_to_list(roads: Dict[Edge, PlayerColor]) -> List[Dict]:
        # Edge needs to be serialized. Edge = (Hex, direction)
        result = []
        for edge, color in roads.items():
            result.append({
                "hex": GameSerializer._hex_to_dict(edge.owner),
                "direction": edge.direction,
                "color": color.value
            })
        return result

    @staticmethod
    def _list_to_roads(data: List[Dict]) -> Dict[Edge, PlayerColor]:
        result = {}
        for item in data:
            h = GameSerializer._dict_to_hex(item["hex"])
            # Recreate canonical edge
            edge = Edge(h, item["direction"]).get_canonical()
            result[edge] = PlayerColor(item["color"])
        return result

    @staticmethod
    def _settlements_to_list(settlements: Dict[Vertex, Building]) -> List[Dict]:
        result = []
        for vertex, building in settlements.items():
            result.append({
                "hex": GameSerializer._hex_to_dict(vertex.owner),
                "direction": vertex.direction,
                "owner": building.owner.value,
                "type": building.type.value
            })
        return result

    @staticmethod
    def _list_to_settlements(data: List[Dict]) -> Dict[Vertex, Building]:
        result = {}
        for item in data:
            h = GameSerializer._dict_to_hex(item["hex"])
            vertex = Vertex(h, item["direction"]).get_canonical()
            result[vertex] = Building(
                owner=PlayerColor(item["owner"]),
                type=BuildingType(item["type"])
            )
        return result

============================================================
FILE: app/schemas/game_schemas.py
============================================================
from pydantic import BaseModel
from typing import List

class GameCreateRequest(BaseModel):
    player_names: List[str]

class GameResponse(BaseModel):
    room_id: str
    status: str
    created_at: str
    players: List[str]

============================================================
FILE: tests/unit/test_harvest.py
============================================================
import pytest
from app.models.game import GameState, TurnPhase
from app.models.board import ResourceType, Tile
from app.models.hex_lib import Hex, Vertex

class TestHarvestMechanics:
    
    def test_distribute_resources_simple(self):
        game = GameState.create_new_game(["Alice", "Bob"])
        alice = game.players[0]

        center_hex = Hex(0,0,0)
        
        # 1. CLEAN BOARD
        game.board.tiles.clear()
        
        game.robber_hex = Hex(100, -100, 0)

        # 3. Setup Logic
        game.board.tiles[center_hex] = Tile(center_hex, ResourceType.WOOD, 6)
        vertex = Vertex(center_hex, 0)
        game.place_settlement(alice, vertex, free=True)
        
        assert alice.resources[ResourceType.WOOD] == 0

        # 4. Trigger
        game.turn_phase = TurnPhase.ROLL_DICE
        game.distribute_resources(6)

        assert alice.resources[ResourceType.WOOD] == 1

    def test_distribute_resources_multiple_players(self):
        game = GameState.create_new_game(["Alice", "Bob"])
        alice = game.players[0]
        bob = game.players[1]

        center_hex = Hex(0,0,0)
        
        game.board.tiles.clear()

        game.robber_hex = Hex(100, -100, 0)
        
        game.board.tiles[center_hex] = Tile(center_hex, ResourceType.WHEAT, 8)

        game.place_settlement(alice, Vertex(center_hex, 0), free=True)
        game.place_settlement(bob, Vertex(center_hex, 3), free=True)

        game.turn_phase = TurnPhase.ROLL_DICE
        game.distribute_resources(8)

        assert alice.resources[ResourceType.WHEAT] == 1
        assert bob.resources[ResourceType.WHEAT] == 1

    def test_no_resources_on_wrong_roll(self):
        game = GameState.create_new_game(["Alice", "Bob"])
        alice = game.players[0]
        
        center_hex = Hex(0,0,0)
        
        game.board.tiles.clear()

        game.robber_hex = Hex(100, -100, 0)
        
        game.board.tiles[center_hex] = Tile(center_hex, ResourceType.ORE, 5)
        
        game.place_settlement(alice, Vertex(center_hex, 0), free=True)
        
        game.turn_phase = TurnPhase.ROLL_DICE
        game.distribute_resources(10)
        
        assert alice.resources[ResourceType.ORE] == 0

============================================================
FILE: tests/unit/test_game_state.py
============================================================
# ============================================================
# FILE: tests/unit/test_game_state.py
# ============================================================
import pytest
from unittest.mock import patch 
from app.models.game import GameState, TurnPhase
from app.models.player import Player, PlayerColor
from app.models.board import ResourceType

class TestPlayerResources:
    def test_add_remove_resources(self):
        p = Player(name="Test", color=PlayerColor.RED)
        p.add_resource(ResourceType.WOOD, 1)
        assert p.resources[ResourceType.WOOD] == 1
        
        p.remove_resource(ResourceType.WOOD, 1)
        assert p.resources[ResourceType.WOOD] == 0

    def test_remove_insufficient_resources(self):
        p = Player(name="Test", color=PlayerColor.RED)
        with pytest.raises(ValueError):
            p.remove_resource(ResourceType.BRICK, 1)

    def test_affordability_check(self):
        p = Player(name="Test", color=PlayerColor.RED)
        p.add_resource(ResourceType.WOOD, 1)
        p.add_resource(ResourceType.BRICK, 1)
        
        road_cost = {ResourceType.WOOD: 1, ResourceType.BRICK: 1}
        city_cost = {ResourceType.ORE: 3, ResourceType.WHEAT: 2}
        
        assert p.has_resources(road_cost) is True
        assert p.has_resources(city_cost) is False

    def test_deduct_resources(self):
        p = Player(name="Test", color=PlayerColor.RED)
        p.add_resource(ResourceType.WOOD, 2)
        p.add_resource(ResourceType.BRICK, 1)
        
        road_cost = {ResourceType.WOOD: 1, ResourceType.BRICK: 1}
        p.deduct_resources(road_cost)
        
        assert p.resources[ResourceType.WOOD] == 1
        assert p.resources[ResourceType.BRICK] == 0

class TestGameState:
    def test_game_initialization(self):
        names = ["Alice", "Bob", "Charlie"]
        game = GameState.create_new_game(names)
        
        assert len(game.players) == 3
        assert game.players[0].color == PlayerColor.RED
        assert game.board is not None
        assert game.current_turn_index == 0
        assert game.turn_phase == TurnPhase.ROLL_DICE

    def test_invalid_player_count(self):
        with pytest.raises(ValueError):
            GameState.create_new_game(["Solo"]) 

    def test_turn_cycle(self):
        names = ["Alice", "Bob"]
        game = GameState.create_new_game(names)
        
        assert game.get_current_player().name == "Alice"
        
        game.next_turn()
        assert game.get_current_player().name == "Bob"
        assert game.turn_phase == TurnPhase.ROLL_DICE
        
        game.next_turn()
        assert game.get_current_player().name == "Alice"

    def test_dice_roll_mocked(self):
        """
        Use a mock to ensure deterministic dice roll.
        random.randint is called twice (for d1 and d2).
        """
        game = GameState.create_new_game(["A", "B"])
        
        # side_effect=[3, 4] means: first call returns 3, second call returns 4.
        # Total sum should be 7.
        with patch('random.randint', side_effect=[3, 4]):
            roll = game.roll_dice()
            
            assert roll == 7
            assert game.dice_roll == 7
            assert game.turn_phase == TurnPhase.MAIN_PHASE

============================================================
FILE: tests/unit/test_building_rules.py
============================================================
# ============================================================
# FILE: tests/unit/test_building_rules.py
# ============================================================
import pytest
from app.models.game import GameState, TurnPhase
from app.models.player import PlayerColor
from app.models.hex_lib import Hex, Vertex, Edge
from app.models.board import ResourceType

class TestBuildingRules:
    
    @pytest.fixture
    def game(self):
        return GameState.create_new_game(["Alice", "Bob"])

    def test_place_initial_settlement_free(self, game):
        """Test placing a settlement during setup (free, no road required)."""
        alice = game.players[0]
        v = Vertex(Hex(0,0,0), 0)
        
        # Free setup bypasses phase check
        game.place_settlement(alice, v, free=True)
        
        # Check structure .owner
        assert game.settlements[v.get_canonical()].owner == PlayerColor.RED
        assert alice.victory_points == 1

    def test_distance_rule(self, game):
        alice = game.players[0]
        v1 = Vertex(Hex(0,0,0), 0)
        v_neighbor = v1.get_adjacent_vertices()[0]
        
        game.place_settlement(alice, v1, free=True)
        
        bob = game.players[1]
        with pytest.raises(ValueError, match="Distance Rule"):
            game.place_settlement(bob, v_neighbor, free=True)

    def test_road_connectivity_required(self, game):
        alice = game.players[0]
        alice.add_resource(ResourceType.WOOD)
        alice.add_resource(ResourceType.BRICK)
        alice.add_resource(ResourceType.WHEAT)
        alice.add_resource(ResourceType.SHEEP)
        
        v = Vertex(Hex(0,0,0), 0)
        
        # To build normally, we must be in MAIN_PHASE
        game.turn_phase = TurnPhase.MAIN_PHASE

        with pytest.raises(ValueError, match="connected to your road"):
            game.place_settlement(alice, v, free=False)

    def test_road_placement_logic(self, game):
        alice = game.players[0]
        v_start = Vertex(Hex(0,0,0), 0)
        
        game.place_settlement(alice, v_start, free=True)
        
        e_connected = v_start.get_touching_edges()[0]
        game.place_road(alice, e_connected, free=True)
        
        assert game.roads[e_connected.get_canonical()] == PlayerColor.RED

        e_far = Edge(Hex(5, -5, 0), 0)
        with pytest.raises(ValueError, match="must be connected"):
            game.place_road(alice, e_far, free=True)

    def test_resource_deduction(self, game):
        alice = game.players[0]
        alice.add_resource(ResourceType.WOOD, 1)
        alice.add_resource(ResourceType.BRICK, 1)
        
        v = Vertex(Hex(0,0,0), 0)
        game.place_settlement(alice, v, free=True)
        e = v.get_touching_edges()[0]
        
        # Switch to Main Phase for paid building
        game.turn_phase = TurnPhase.MAIN_PHASE

        game.place_road(alice, e, free=False)
        
        assert alice.resources[ResourceType.WOOD] == 0
        assert alice.resources[ResourceType.BRICK] == 0
        assert game.roads[e.get_canonical()] == PlayerColor.RED

============================================================
FILE: tests/unit/test_hex_lib.py
============================================================
import pytest
from app.models.hex_lib import Hex, Vertex, Edge

class TestHexCore:
    def test_hex_creation_valid(self):
        h = Hex(0, -1, 1)
        assert h.q == 0

    def test_hex_neighbors(self):
        center = Hex(0, 0, 0)
        neighbor = center.neighbor(0)
        assert neighbor == Hex(1, 0, -1)

class TestVertexCanonicalization:
    def test_canonical_vertex_equality(self):
        """
        Test that the same physical vertex accessed from 3 different hexes
        resolves to the same canonical Vertex object.
        """
        # Center hex (0,0,0)
        h_center = Hex(0, 0, 0)
        
        # Neighbor at direction 0 (1, 0, -1)
        h_neighbor_0 = h_center.neighbor(0)
        
        # Neighbor at direction 5 (0, 1, -1)
        h_neighbor_5 = h_center.neighbor(5)

        # The vertex '0' of Center is shared by Neighbor 0 and Neighbor 5.
        # Perspective 1: Center, Vertex 0
        v1 = Vertex(h_center, 0).get_canonical()
        
        # Perspective 2: Neighbor 0. 
        # Looking back at Center (dir 3) and Neighbor 5 (dir 4). 
        # The vertex between 3 and 4 is Vertex 4.
        v2 = Vertex(h_neighbor_0, 4).get_canonical()
        
        # Perspective 3: Neighbor 5.
        # Looking back at Neighbor 0 (dir 1) and Center (dir 2).
        # The vertex between 1 and 2 is Vertex 2.
        v3 = Vertex(h_neighbor_5, 2).get_canonical()

        # They MUST be identical
        assert v1 == v2
        assert v2 == v3
        assert v1 == v3

    def test_vertex_set_usage(self):
        """Verify that canonical vertices work correctly in sets (hashing)."""
        h_center = Hex(0, 0, 0)
        h_neighbor = h_center.neighbor(0)
        
        # Same geometric point (Vertex 0 of Center == Vertex 4 of Neighbor 0)
        v1 = Vertex(h_center, 0).get_canonical()
        v2 = Vertex(h_neighbor, 4).get_canonical()
        
        vertex_set = set()
        vertex_set.add(v1)
        vertex_set.add(v2)
        
        # Should only have 1 element because v1 and v2 represent the same point
        assert len(vertex_set) == 1

class TestEdgeCanonicalization:
    def test_canonical_edge_equality(self):
        """
        Test that the same physical edge accessed from 2 adjacent hexes
        resolves to the same canonical Edge object.
        """
        h1 = Hex(0, 0, 0)
        h2 = h1.neighbor(0) # Neighbor to the right/top-right

        # Edge 0 of h1 is shared with Edge 3 (opposite) of h2
        e1 = Edge(h1, 0).get_canonical()
        e2 = Edge(h2, 3).get_canonical()

        assert e1 == e2

    def test_edge_set_usage(self):
        h1 = Hex(0, 0, 0)
        h2 = h1.neighbor(1)
        
        # Edge 1 of h1 touches Edge 4 of h2
        e1 = Edge(h1, 1).get_canonical()
        e2 = Edge(h2, 4).get_canonical()
        
        edge_set = {e1, e2}
        assert len(edge_set) == 1

============================================================
FILE: tests/unit/test_board.py
============================================================
import pytest
from collections import Counter
from app.models.board import Board, ResourceType, Tile
from app.models.hex_lib import Hex

class TestBoardGenerator:
    
    def test_standard_board_size(self):
        """Standard board (radius 2) should have 19 tiles."""
        board = Board.create_standard_game()
        assert len(board.tiles) == 19

    def test_resource_distribution(self):
        """Check if the exact count of resources is present."""
        board = Board.create_standard_game()
        resources = [t.resource for t in board.tiles.values()]
        counts = Counter(resources)

        assert counts[ResourceType.WOOD] == 4
        assert counts[ResourceType.SHEEP] == 4
        assert counts[ResourceType.WHEAT] == 4
        assert counts[ResourceType.BRICK] == 3
        assert counts[ResourceType.ORE] == 3
        assert counts[ResourceType.DESERT] == 1

    def test_number_distribution(self):
        """Check if numbers are correct (no 7, specific counts)."""
        board = Board.create_standard_game()
        # Filter out None (Desert)
        numbers = [t.number for t in board.tiles.values() if t.number is not None]
        counts = Counter(numbers)

        # Total numbered tiles should be 18
        assert len(numbers) == 18
        
        # 7 should not exist
        assert 7 not in counts
        
        # Check specific frequencies (examples)
        assert counts[2] == 1
        assert counts[12] == 1
        assert counts[6] == 2
        assert counts[8] == 2

    def test_desert_has_no_number(self):
        """Desert tile must verify number is None."""
        board = Board.create_standard_game()
        desert_tiles = [t for t in board.tiles.values() if t.resource == ResourceType.DESERT]
        
        assert len(desert_tiles) == 1
        assert desert_tiles[0].number is None

    def test_coordinate_lookup(self):
        """Test verifying we can retrieve a tile by coordinate."""
        board = Board.create_standard_game()
        center = Hex(0, 0, 0)
        
        tile = board.get_tile(center)
        assert tile is not None
        assert isinstance(tile, Tile)
        assert tile.hex_coords == center

    def test_out_of_bounds_lookup(self):
        """Test lookup for a hex that doesn't exist."""
        board = Board.create_standard_game()
        far_away = Hex(10, -10, 0)
        
        assert board.get_tile(far_away) is None

============================================================
FILE: tests/integration/test_redis_persistance.py
============================================================
import pytest
import pytest_asyncio
from app.models.game import GameState
from app.services.serializer import GameSerializer
from app.services.redis_service import RedisService

@pytest.mark.asyncio
async def test_full_game_persistence_cycle():
    """
    Integration Test:
    1. Creates a real GameState.
    2. Serializes it.
    3. Saves it to a REAL Redis instance.
    4. Loads it back.
    5. Deserializes it.
    6. Verifies data integrity.
    """
    
    # 1. Setup
    service = RedisService()
    room_id = "integration_test_room_123"
    
    # Create a game and modify it slightly (roll dice) to ensure state is captured
    original_game = GameState.create_new_game(["Alice", "Bob"])
    original_game.roll_dice() 
    original_turn_idx = original_game.current_turn_index
    original_dice = original_game.dice_roll

    # 2. Serialize & Save
    game_dict = GameSerializer.game_to_dict(original_game)
    await service.save_game_state(room_id, game_dict)

    # 3. Load from Redis
    loaded_dict = await service.get_game_state(room_id)
    
    # Assert Redis actually returned data
    assert loaded_dict is not None, "Redis returned None, save failed."

    # 4. Deserialize
    loaded_game = GameSerializer.dict_to_game(loaded_dict)

    # 5. Verify Data Integrity
    assert len(loaded_game.players) == 2
    assert loaded_game.players[0].name == "Alice"
    assert loaded_game.players[1].name == "Bob"
    
    # Verify State Persistence
    assert loaded_game.dice_roll == original_dice
    assert loaded_game.current_turn_index == original_turn_idx
    
    # Verify Board Integrity (Check just one tile to be sure)
    # We check if the count of tiles is preserved
    assert len(loaded_game.board.tiles) == 19

    # Cleanup
    await service.redis.delete(f"game:{room_id}")
    await service.close()